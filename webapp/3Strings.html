<!-- full content with additional manual implementations for optimized inbuilt cases -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Placement-Focused Strings Page</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      height: 100vh;
    }
    .sidebar {
      width: 250px;
      background-color: #1e1e2f;
      color: white;
      padding: 20px;
      box-sizing: border-box;
    }
    .sidebar h2 {
      margin-top: 0;
      font-size: 20px;
    }
    .sidebar a {
      display: block;
      color: #cfcfcf;
      text-decoration: none;
      margin: 10px 0;
      transition: color 0.2s ease;
    }
    .sidebar a:hover {
      color: #ffffff;
    }
    .content {
      flex: 1;
      padding: 30px;
      overflow-y: auto;
    }
    .content h2 {
      margin-top: 60px;
      border-bottom: 2px solid #ccc;
      padding-bottom: 5px;
    }
    pre {
      background: #f4f4f4;
      padding: 15px;
      overflow-x: auto;
      border-radius: 6px;
    }
    .explanation {
      background: #e8f0fe;
      padding: 10px;
      border-left: 4px solid #4285f4;
      margin: 20px 0;
      border-radius: 6px;
    }
.scrollable-div {
  max-height: 250px;
  overflow-y: auto;
  border: 2px solid #666;
  padding: 15px;
  background-color: #f5f5f5;
  border-radius: 6px;
  position: relative;
  margin-bottom: 40px;
}

.print-button {
  position: sticky;
  bottom: 5px;
  float: right;
  padding: 8px 14px;
  background-color: #007bff;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 10px;
}

@media print {
  body * {
    visibility: hidden;
  }
  #printable-content, #printable-content * {
    visibility: visible;
  }
  #printable-content {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    overflow: visible;
  }
  .print-button {
    display: none;
  }
}

  </style>
</head>
<body>
  <div class="sidebar">
    <h2>String Topics</h2>
    <a href="#anagram">Anagram Check</a>
    <a href="#palindrome">Palindrome Check</a>
    <a href="#prefix">Prefix Match</a>
    <a href="#toggle">Toggle Case</a>
    <a href="#frequency">Character Frequency</a>
    <a href="#mock1">Mock Interview 1</a>
    <a href="#mock2">Mock Interview 2</a>
  </div>


<div class="content" id="printable-content">
 
<button class="print-button" onclick="window.print()">üñ®Ô∏è Print</button>
    <h1>Placement Preparation: Strings</h1>

    <!-- Example for Anagram updated below -->
    <h2 id="anagram">Anagram Check</h2>
    <p><strong>Problem Statement:</strong> Check if two strings are anagrams of each other.</p>

    <h3>Brute-force Approach (Python)</h3>
    <pre><code>def is_anagram_brute(s1, s2):
    if len(s1) != len(s2): return False
    for ch in s1:
        if s1.count(ch) != s2.count(ch):
            return False
    return True</code></pre>
    <div class="explanation">Time: O(n^2), Space: O(1)</div>

    <h3>Optimized Approach using inbuilt sorted (Python)</h3>
    <pre><code>def is_anagram_sorted(s1, s2):
    return sorted(s1) == sorted(s2)</code></pre>
    <div class="explanation">Time: O(n log n), Space: O(n)</div>

    <h3>Optimized Manual Approach using Hash Map (Python)</h3>
    <pre><code>def is_anagram_hashmap(s1, s2):
    if len(s1) != len(s2): return False
    count = {}
    for ch in s1:
        count[ch] = count.get(ch, 0) + 1
    for ch in s2:
        if ch not in count or count[ch] == 0:
            return False
        count[ch] -= 1
    return True</code></pre>
    <div class="explanation">Time: O(n), Space: O(k) ‚Äì where k is charset size</div>

    <h2 id="palindrome">Palindrome Check</h2>
<p><strong>Problem Statement:</strong> Determine if a given string is a palindrome (reads the same forwards and backwards).</p>

<h3>Brute-force Approach (Python)</h3>
<pre><code>def is_palindrome_brute(s):
    reversed_s = ""
    for ch in s:
        reversed_s = ch + reversed_s
    return s == reversed_s</code></pre>
<div class="explanation">Time: O(n^2), Space: O(n)</div>

<h3>Optimized Approach using slicing (Python)</h3>
<pre><code>def is_palindrome_slice(s):
    return s == s[::-1]</code></pre>
<div class="explanation">Time: O(n), Space: O(n)</div>

<h3>Optimized Manual Two-Pointer Approach (Python)</h3>
<pre><code>def is_palindrome_two_pointer(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True</code></pre>
<div class="explanation">Time: O(n), Space: O(1)</div>

<h2 id="prefix">Prefix Match</h2>
<p><strong>Problem Statement:</strong> Check if a string starts with a given prefix.</p>

<h3>Brute-force Approach (Python)</h3>
<pre><code>def has_prefix_brute(s, prefix):
    for i in range(len(prefix)):
        if i >= len(s) or s[i] != prefix[i]:
            return False
    return True</code></pre>
<div class="explanation">Time: O(k), Space: O(1)</div>

<h3>Optimized Approach using inbuilt startswith (Python)</h3>
<pre><code>def has_prefix_builtin(s, prefix):
    return s.startswith(prefix)</code></pre>
<div class="explanation">Time: O(k), Space: O(1)</div>

<h2 id="toggle">Toggle Case</h2>
<p><strong>Problem Statement:</strong> Toggle the case of each character in a string.</p>

<h3>Brute-force Approach (Python)</h3>
<pre><code>def toggle_case_brute(s):
    result = ""
    for ch in s:
        if ch.islower():
            result += ch.upper()
        else:
            result += ch.lower()
    return result</code></pre>
<div class="explanation">Time: O(n^2) (string concatenation), Space: O(n)</div>

<h3>Optimized Approach using list join (Python)</h3>
<pre><code>def toggle_case_list(s):
    return ''.join([ch.lower() if ch.isupper() else ch.upper() for ch in s])</code></pre>
<div class="explanation">Time: O(n), Space: O(n)</div>

<h2 id="frequency">Character Frequency</h2>
<p><strong>Problem Statement:</strong> Count the frequency of each character in a string.</p>

<h3>Brute-force Approach (Python)</h3>
<pre><code>def char_frequency_brute(s):
    freq = {}
    for ch in s:
        count = 0
        for c in s:
            if ch == c:
                count += 1
        freq[ch] = count
    return freq</code></pre>
<div class="explanation">Time: O(n^2), Space: O(n)</div>

<h3>Optimized Approach using Counter (Python)</h3>
<pre><code>from collections import Counter

def char_frequency_counter(s):
    return dict(Counter(s))</code></pre>
<div class="explanation">Time: O(n), Space: O(k)</div>

<h3>Optimized Manual Approach using Dictionary (Python)</h3>
<pre><code>def char_frequency_dict(s):
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    return freq</code></pre>
<div class="explanation">Time: O(n), Space: O(k)</div>

<h2 id="mock1">Mock Interview 1</h2>
<p><strong>Problem Statement:</strong> Find the longest common prefix among an array of strings.</p>

<h3>Brute-force Approach (Python)</h3>
<pre><code>def longest_common_prefix_brute(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix</code></pre>
<div class="explanation">Time: O(n*m), Space: O(m)</div>

<h3>Optimized Approach (Python)</h3>
<pre><code>def longest_common_prefix_optimized(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
    return prefix</code></pre>
<div class="explanation">Time: O(n*m), Space: O(1)</div>

<h2 id="mock2">Mock Interview 2</h2>
<p><strong>Problem Statement:</strong> Given a string, return the first non-repeating character.</p>

<h3>Brute-force Approach (Python)</h3>
<pre><code>def first_unique_char_brute(s):
    for i in range(len(s)):
        is_unique = True
        for j in range(len(s)):
            if i != j and s[i] == s[j]:
                is_unique = False
                break
        if is_unique:
            return s[i]
    return None</code></pre>
<div class="explanation">Time: O(n^2), Space: O(1)</div>

<h3>Optimized Approach using Counter (Python)</h3>
<pre><code>from collections import Counter

def first_unique_char_counter(s):
    freq = Counter(s)
    for ch in s:
        if freq[ch] == 1:
            return ch
    return None</code></pre>
<div class="explanation">Time: O(n), Space: O(k)</div>

<h3>Optimized Manual Approach using Dictionary (Python)</h3>
<pre><code>def first_unique_char_dict(s):
    freq = {}
    for ch in s:
        freq[ch] = freq.get(ch, 0) + 1
    for ch in s:
        if freq[ch] == 1:
            return ch
    return None</code></pre>
<div class="explanation">Time: O(n), Space: O(k)</div>

  </div>
</body>
</html>
